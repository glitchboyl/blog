---
title: 通过遍历序列构造二叉树
date: 2023-04-28
---



二叉树的遍历序列有以下四种：
- 先序遍历 (Pre-Order): 根-左-右
- 中序遍历 (In-Order): 左-根-右
- 后序遍历 (Post-Order): 左-右-根
- 层序遍历 (Level-Order): 按照树的层从上到下，每一层从左到右

假如给一组数据 `1, 2, 3, 4, 5, 6`，然后告诉你它是一棵二叉树的某个遍历序列，让你构造还原成二叉树，应该是绝对不可能的。
因为它即便根据性质确定了树的根节点，然而剩下的每个元素都有可能是子树的根结点，且无法确定子树到底是左子树还是右子树。
结论就是：**若只给出一棵二叉树的一种遍历序列数据，不能唯一确定一棵二叉树**。

---

要构建一棵二叉树需要给出下列组合其中一种：
- 先序 + 中序遍历序列
- 后序 + 中序遍历序列
- 层序 + 中序遍历序列

其中，中序遍历序列是必要的。<br>
因为在性质上，先序、后序和层序都能够确定树的根结点，而无法确定左子树和右子树。<br>
而中序遍历序列无法确定树的根结点，但一旦确定了树的根节点，它便能根据根节点分开成左子树和右子树。<br>
两两互补之后，一棵二叉树就能被确定了。

那实现构造二叉树的思路就很简单了：<br>
找到树的根节点，然后在中序遍历序列中分开成左子树和右子树，然后再以相同的规则递归创建左子树和右子树。

完整的实现代码请点[这里](https://github.com/glitchboyl/CS/blob/main/DataStructure/LinkedTree.c)查看。

----

在通过层序 + 中序遍历序列构造二叉树的方法中，我使用了一个循环语句来分开层序遍历序列中的左子树和右子树的元素。<br>
这一段其实写的并不好，套层循环使得时间复杂度到 O(n^2)。<br>
具体可以优化成第一次通过循环查找根结点在中序遍历数组中的下标时，使用哈希表来储存遍历过的中序遍历数组下标，之后便可以直接获取使用。这样的话时间复杂度就是 O(n)。

之后学完散列表再看看要不要回来优化吧，C 语言实现 Hash Table 好像还挺难受的。

~~想到再补充。~~
