---
title: æˆ‘å¯¹åŠ¨æ€è§„åˆ’çš„ç†è§£
date: 2023-11-24
---



è¿‘äº›æ—¥å­ä¸€ç›´åœ¨åˆ· [leetcode](https://leetcode.com/glitchboyl/)ï¼Œé™¤äº†å­¦ä¹ ä¸€äº›æ•°æ®ç»“æ„å’Œç®—æ³•æ€ç»´ï¼Œä¹Ÿç®—æ˜¯ä¸ºæ‰¾å·¥ä½œåšå‡†å¤‡ã€‚

åˆ·é¢˜åˆ·å¤šäº†å°±ä¼šå‘ç°ï¼Œç®—æ³•æŠ€å·§å°±é‚£å‡ ä¸ªå¥—è·¯ï¼ŒæŠŠå„ç§è§£é¢˜æ¡†æ¶å¥—è¿›å»åŸºæœ¬éƒ½èƒ½è§£ï¼Œbut

åœ¨è¿™é‡Œé¢æœ‰ç±»é¢˜ç›®æœ€ä»¤æˆ‘å¤´ç–¼çš„ï¼Œä¹Ÿæ˜¯é¢è¯•å¸¸è€ƒçš„ç®—æ³•ç±»å‹ï¼š**åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programmingï¼‰**ï¼Œç®€ç§° DPã€‚

~~å½“ç„¶å…¶å®æ‰€æœ‰ç®—æ³•é¢˜éƒ½ä»¤æˆ‘å¤´ç–¼ï¼Œç®—æ³•è‹¦æ‰‹ :cry:~~

---

å¼•ç”¨ [wikipedia](https://en.wikipedia.org/wiki/Dynamic_programming) å¯¹åŠ¨æ€è§„åˆ’çš„æè¿°ï¼š

> ...it refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a [recursive](https://en.wikipedia.org/wiki/Recursion) manner. 

è®²äººè¯å°±æ˜¯ï¼š

> åŠ¨æ€è§„åˆ’æ˜¯ä»¥é€’å½’çš„æ–¹å¼å»å°†å¤æ‚çš„é—®é¢˜åˆ†è§£ä¸ºæ›´ç®€å•çš„å­é—®é¢˜æ¥ç®€åŒ–é—®é¢˜ã€‚

åŠ¨æ€è§„åˆ’è§£å†³é—®é¢˜çš„å…³é”®ç‰¹å¾å’Œæ­¥éª¤åŒ…æ‹¬ï¼š

- æœ€ä¼˜å­ç»“æ„ï¼šå°†é—®é¢˜åˆ†è§£æˆå­é—®é¢˜ä¹‹åæ±‚å‡ºçš„å­é—®é¢˜çš„æœ€ä¼˜è§£ã€‚
- çŠ¶æ€è½¬ç§»ï¼šåˆ©ç”¨æœ€ä¼˜å­ç»“æ„ï¼Œå®šä¹‰é—®é¢˜çŠ¶æ€ä¹‹é—´çš„å…³ç³»ï¼Œæ„é€ é—®é¢˜çš„æœ€ä¼˜è§£ã€‚
- å­˜å‚¨ä¸­é—´ç»“æœï¼šé¿å…é‡å¤è®¡ç®—ï¼Œæé«˜æ•ˆç‡ã€‚

å¦‚æœé—®é¢˜å…·å¤‡ä»¥ä¸Šä¸‰ç‚¹ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªå…¸å‹çš„åŠ¨æ€è§„åˆ’é—®é¢˜ã€‚

~~ä½†å°±éš¾åœ¨æˆ‘å¯Ÿè§‰ä¸åˆ°å®ƒå…·å¤‡ã€‚~~

åŠ¨æ€è§„åˆ’é—®é¢˜ä¸€èˆ¬éƒ½æ˜¯æ±‚æœ€å€¼ï¼Œä¾‹å¦‚ [62. Unique Paths](https://leetcode.com/problems/unique-paths/) æ±‚åˆ°è¾¾å³ä¸‹è§’ï¼ˆæœ€å¤šï¼‰æœ‰å‡ ç§è·¯å¾„ï¼Œ

æˆ–æ˜¯ [72. Edit Distance](https://leetcode.com/problems/edit-distance/) æ±‚ä» word1 å˜æˆ word2 æœ€å°‘ç¼–è¾‘æ¬¡æ•°ï¼Œetc...

ä¸€èˆ¬é‡åˆ°è¿™ç±»é—®é¢˜ï¼Œé™¤äº†ç©·ä¸¾å‡ºæ‰€æœ‰ç­”æ¡ˆé€‰æ‹©æœ€å€¼ï¼Œå‹æ ¹æƒ³ä¸åˆ°ä»€ä¹ˆè§£å†³æ–¹æ³•ã€‚æ¥ä¸‹æ¥æˆ‘å°±è¯•ç€ä¸¾å‡ ä¸ªä¾‹å­æ¥è®²è®²æˆ‘å¦‚ä½•ç†è§£åŠ¨æ€è§„åˆ’ã€‚

---

### [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)

æ–æ³¢é‚£å¥‘æ•°åˆ—æ˜¯ä¸€ä¸ªå¾ˆå…¸å‹çš„é€’å½’é—®é¢˜ï¼Œè§£æ³•éå¸¸ç®€å•ï¼š

```rust
fn fib(n) -> i32 {
  if n <= 1 {
    return n;
  }
  fib(n - 1) + fib(n - 2)
}
```

ä½†è¿™æ ·è§£æœ‰ä¸ªé—®é¢˜ï¼Œåœ¨ç®— `fib(n - 1)` æ—¶ï¼Œå®é™…ä¸Šä¹Ÿè®¡ç®—äº† `fib(n - 2)`ï¼Œè¿™æ ·å°±å¯¼è‡´äº†é‡å¤è®¡ç®—ã€‚

å¯ä»¥é€šè¿‡å»ºç«‹ä¸€ä¸ª map æ¥å‚¨å­˜å·²ç»è®¡ç®—è¿‡çš„å€¼æ¥ä¼˜åŒ–ï¼š

```rust
fn fib(n) -> i32 {
  let mut map = vec![0, 1];
  for i in 2..=n {
    map[i] = map[i - 1] + map[i - 2];
  }
  map[n]
}
```

ä¸Šé¢è¿™ç§æ–¹å¼å…¶å®å°±æ˜¯ç”¨[åŠ¨æ€è§„åˆ’](https://en.wikipedia.org/wiki/Dynamic_programming#Fibonacci_sequence)æ¥è§£å†³ï¼Œè¦è®¡ç®—åŸé—®é¢˜ `fib(n)`ï¼Œéœ€è¦å…ˆè®¡ç®—å®ƒçš„å­é—®é¢˜ `fib(n - 1)` å’Œ `fib(n - 2)`ï¼Œè€Œè®¡ç®— `fib(n - 1)` åˆè¦è®¡ç®—å®ƒçš„å­é—®é¢˜ `fib(n - 2)` å’Œ `fib(n - 3)`... ä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°å®ƒçš„ base case `fib(0) = 0` å’Œ `fib(1) = 1`ã€‚

ç„¶åå†ä» base case è‡ªåº•å‘ä¸Šæ¨å‡ºæ‰€æœ‰å­é—®é¢˜çš„ç­”æ¡ˆï¼Œæœ€ç»ˆå¾—åˆ°é—®é¢˜çš„ç­”æ¡ˆã€‚è¿™ä¸ªè‡ªåº•å‘ä¸Šçš„è¿‡ç¨‹å°±æ˜¯**çŠ¶æ€è½¬ç§»**ï¼Œåœ¨å¾ªç¯å†…ï¼Œ`i` çš„å€¼ä¼šä¸æ–­å˜åŒ–ï¼Œå¦‚æœæŠŠ `i` å½“åšä¸€ä¸ªçŠ¶æ€ï¼Œè¿™ä¸ªçŠ¶æ€å°±æ˜¯ç”±çŠ¶æ€ `i - 1` å’ŒçŠ¶æ€ `i - 2` è½¬ç§»ï¼ˆç›¸åŠ ï¼‰è€Œæ¥ã€‚

åŠ¨æ€è§„åˆ’çš„éš¾ç‚¹ï¼Œå°±æ˜¯å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚æ¥ç€çœ‹ã€‚

---

### [62. Unique Paths](https://leetcode.com/problems/unique-paths/)

ç»™ä¸€ä¸ª m Ã— n çš„ç½‘æ ¼ï¼Œåªèƒ½å‘å³æˆ–è€…å‘ä¸‹ç§»åŠ¨ï¼Œæ±‚å‡ºä»æœ€å·¦ä¸Šè§’åˆ°æœ€å³ä¸‹è§’æœ‰å‡ ç§è·¯å¾„ã€‚

![grid](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

é¦–å…ˆæ˜¯ç©·ä¸¾çš„å†™æ³•ï¼š

```rust
fn unique_paths(m: i32, n: i32) -> i32 {
  fn move_to(i: i32, j: i32, m: i32, n: i32) -> i32 {
    // reach the goal
    if i == m - 1 && j == n - 1 {
      return 1;
    }
    // boundary handle
    if i == m || j == n { 
      return 0;
    }
    // only move to right or down
    move_to(i, j + 1, m, n) + move_to(i + 1, j, m, n)
  }
  move_to(0, 1, m, n) + move_to(1, 0, m, n)
}
```

åªèƒ½å‘å³æˆ–è€…å‘ä¸‹ç§»åŠ¨ï¼Œé€šè¿‡é€’å½’è°ƒç”¨è€ƒè™‘è¿™ä¸¤ç§ç§»åŠ¨çš„æƒ…å†µï¼š

- å½“ `i == m - 1 && j == n - 1` æ—¶è¯´æ˜å·²ç»åˆ°è¾¾ç›®çš„åœ°ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯ä¸€æ¡æœ‰æ•ˆè·¯å¾„ï¼Œè¿”å› 1ã€‚
- å½“ `i == m || j == n` æ—¶è¯´æ˜è¶…å‡ºäº†è¾¹ç•Œï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€æ¡æ— æ•ˆè·¯å¾„ï¼Œè¿”å› 0ã€‚

è¿™ç§é€’å½’å®ç°ä¼šæ¶‰åŠå¤§é‡çš„é‡å¤è®¡ç®—ï¼Œå› ä¸ºåœ¨è®¡ç®—ä¸€ä¸ªè·¯å¾„çš„å¯èƒ½æ€§æ—¶å¤šæ¬¡è®¡ç®—äº†ç›¸åŒä½ç½®çš„å­é—®é¢˜ã€‚

ç”¨åŠ¨æ€è§„åˆ’æ¥è§£å†³é—®é¢˜ï¼Œbase case ä¸º `m = 1 || n = 1` æ—¶ï¼Œé‚£ä¹ˆå®ƒåªæœ‰ 1 æ¡è·¯å¾„æ•°ã€‚

å°†é—®é¢˜åˆ†è§£ä¸ºæ±‚ä»æœ€å·¦ä¸Šè§’åˆ°æŸä¸ªæ ¼çš„è·¯å¾„æ•°ï¼Œå› ä¸ºåªèƒ½å‘å³æˆ–è€…å‘ä¸‹ç§»åŠ¨ï¼Œé‚£ä¹ˆå…¶å®çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š

> ç§»åŠ¨åˆ°æŸä¸€æ ¼çš„è·¯å¾„æ•° = ç§»åŠ¨åˆ°è¯¥æ ¼å·¦è¾¹æ ¼å­çš„è·¯å¾„æ•° + ç§»åŠ¨åˆ°è¯¥æ ¼ä¸Šè¾¹æ ¼å­çš„è·¯å¾„æ•°

åˆ›å»ºä¸€ä¸ª m Ã— n çš„äºŒç»´æ•°ç»„ `dp`ï¼Œ`dp[i][j]` æ‰€è¡¨ç¤ºçš„æ˜¯ä» `(0, 0)` åˆ° `(i, j)` çš„è·¯å¾„æ•°ã€‚

```rust
fn unique_paths(m: i32, n: i32) -> i32 {
  // initialize dp
  let mut dp = vec![vec![1; n]; m];
  for i in 1..m {
    for j in 1..n {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  dp[m - 1][n - 1]
}
```

è¿™æ ·åŠ¨æ€è§„åˆ’è§£æ³•å°±å®Œæˆäº†ã€‚å…¶å®è¿™é¢˜è¿˜å¯ä»¥åˆ©ç”¨æ•°å­¦ä¸­çš„ç»„åˆæ¥è§£ï¼š

å› ä¸ºç§»åŠ¨é™åˆ¶ï¼Œæ‰€ä»¥æ¯ä¸€æ¡è·¯å¾„ç»è¿‡çš„æ ¼å­æ•°éƒ½æ˜¯ä¸€æ ·çš„ï¼Œéƒ½éœ€è¦èµ° `(m - 1) + (n - 1)` æ­¥ã€‚å³æ¯æ¡è·¯å¾„ï¼Œéƒ½éœ€è¦å‘ä¸‹ç§»åŠ¨ `(m - 1)` æ¬¡ï¼Œå‘å³ç§»åŠ¨ `(n - 1)` æ¬¡ï¼Œç§»åŠ¨çš„ç»„åˆå³ä¸ºè·¯å¾„æ•°ï¼Œå› æ­¤å¯ä»¥å¾—åˆ°å…¬å¼ï¼š ![test.image.latex](./latex.svg)

```rust
fn unique_paths(m: i32, n: i32) -> i32 {
  // use shadowing: m -> (m - 1), n -> (n - 1)
  let m = m as u64 - 1;
  let n = n as u64 - 1;
  (1..=n).fold(1u64, |acc, x| acc * (m + x) / x) as _
}
```

~~ä½†åƒæˆ‘è¿™ç§ ğŸ¥¬:dog: å“ªé‡Œæƒ³å¾—åˆ°~~

