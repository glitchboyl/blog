---
title: 我对 KMP 算法的理解
date: 2023-04-25
---



最近学到了一个算法叫 **KMP**，其实以前也有听说过，但是压根没去深入了解它，趁着这次有机会学习一下。

OK，先 copy 点我听不懂的：
- KMP算法（Knuth-Morris-Pratt Algorithm）是一种字符串匹配算法，在文本串中查找一个子串。与文本串和模式串的长度无关，是一种非常高效的字符串匹配算法之一。

- 它的核心思想是利用已知信息避免不必要的字符比较。

  具体来说，它对每个模式串前缀计算出一个最长公共前后缀长度（记为“next”数组），然后在匹配过程中，根据 next 数组跳过已经匹配的前缀，从而提高匹配效率。

- KMP算法的实现过程大致如下：<br>
  1.预处理模式串，计算 next 数组；<br>
  2.在文本串中从左到右匹配模式串，并根据 next 数组跳过已经匹配的前缀。

以上信息里的 keywords 就是：**利用已知信息避免不必要的比较**、**最长公共前后缀** 和 **跳过**。

---

首先，字符串的暴力解法是通过一一比较文本串和模式串的字符，假如它们的前 i 位都是相同的，当第 i + 1 位不相同时，指针就要回溯到文本串第 2 位重新开始比较，那这之前做的 i 次循环都会变成无用功，这样时间复杂度在最差时能达到 O(nm)。<br>
KMP 算法就是不浪费之前做的循环工作，通过前 j 次循环得到了文本串的前 j 位子串的信息，这说明文本串和模式串的前 j 位都是相同的，那么就可以用空间换时间秀操作，想想用什么办法可以不回溯那么多位。

然后来解释一下什么是公共前后缀。<br>
假设有一个字符串 `"abcde"`，那么它的真前缀集合为字符串从开头开始算，除去整个字符串本身的所有子串：

```
{ 'a', 'ab', 'abc', 'abcd'}
```
真后缀集合为从末尾开始算，除去整个字符串本身的所有子串：
```
{'e', 'de', 'cde', 'bcde'}
```
这个最长公共前后缀，其实就是最长相等的真前缀和真后缀的意思。

为什么要计算这个最长公共前后缀呢？当字符串有相同的前缀和后缀时，那么我就可以**跳过**前缀的部分，直接把模式串指针回溯到**后缀的开头把它当成前缀部分**（**因为前缀部分已经是确认相同的了**）重新进行比较，文本串指针就可以一直前进而不必回溯，这样使得可以在线性的时间里解决字符串的匹配，时间复杂度为 O(n+m)。

那么具体操作就是对模式串进行预处理，计算它的每一位的最长公共前后缀，并把这些信息放在一个 next 数组中，而这个 next 数组其实就是 KMP 算法中最难理解的，需要使用双指针计算每个位置的公共前后缀，以及回溯位置等操作。

---

那么如何求这个 next 数组呢？假设我的模式串 p 为 `"abacabab"`，则 next 数组为一个长度为 8 的数组。<br>
要计算它每一位的最长公共前后缀，需要用到双指针，一个指针来找前缀，一个指针来找后缀，预处理的过程如下：

1. 设置 **i = 0, j = 1**。其中 i 为查询前缀的指针，j 为查询后缀的指针。当第 i 位字符串和第 j 位字符串相同时，说明 **第 0 到 i 位的字符串** 和 **第 j-i+1 到 j 位字符串** 是相等的，长度为 i-1。也就是说我们要求的就是 [0...i] == [j-i+1...j]。
2. 因为从下标为 0 到 0 组成的子串只有一个字符，它没有最长公共前后缀，所以 next[0] 只能记为 0。可以直接从模式串的第 2 位也就是下标为 1 的地方开始计算。
   ```
   i=0
   ↓
   abacabab
    ↑
    j=1
   ```
   比较 p[i] 和 p[j]，它们不相同。所以 next[j] = i 即 next[1] = 0。
3. 然后 j++。

   ```
   i=0
   ↓
   abacabab
     ↑
     j=2
   ```
   比较 p[i] 和 p[j]，它们相同。这说明从下标为 0 到 2 组成的子串它的最大公共前后缀是 p[i] 和 p[j]，长度是 1。<br>
   令 i++，因为下一步需要判断下一位是否相同。 next[j] = i 即 next[2] = 1。
5. 然后 j++。
   ```
    i=1
    ↓
   abacabab
      ↑
      j=3
   ```
   比较 p[i] 和 p[j]，它们不相同。因为上一次计算后知道了从下标为 0 到 2 组成的子串它的最大公共前后缀是 1，但加上下标为 3 的字符后组成的新子串没有构成一个更长的公共前后缀，也就是说从下标为 0 到 3 组成的子串它没有公共前后缀，长度为 0。<br>
    但是因为下标为 0 到 2 组成的子串是有最大公共前后缀的，其实这里能够获取到的一个隐藏信息是：**这个子串的真前缀和真后缀因为是相等的，而它们自身的最大公共前后缀也是相同的**。<br>
    那么我其实可以把 i 回溯到 **这个子串的真前缀** 的 **最大公共前后缀的长度** 的位置，接着往后计算前后缀是否相同，即令 i = next[i-1]。<br>
    这里因为下标为 0 到 2 组成的子串的最大公共前后缀为 `'a'`，它自身的最大公共前后缀长度是 0，刚好把 i 给初始化回 0 了，那就没有计算的意义，那么 next[j] = i 即 next[3] = 0。
6. 然后 j++。
   ```
   i=0
   ↓
   abacabab
       ↑
       j=4
   ```
   比较 p[i] 和 p[j]，它们相同。然后 blabla 和步骤 3 一个意思。令 i++， next[j] = i 即 next[4] = 1。
7. 然后 j++。
   ```
    i=1
    ↓
   abacabab
        ↑
        j=5
   ```
   比较 p[i] 和 p[j]，它们相同，从下标为 0 到 4 组成的子串 加上 下标为 5 的字符 后组成的新子串构成了一个更长的公共前后缀。令 i++， next[j] = i 即 next[5] = 2。
8. 然后 j++。
   ```
     i=2
     ↓
   abacabab
         ↑
         j=6
   ```
    比较 p[i] 和 p[j]，它们相同，blabla 和步骤 6 一个意思。令 i++， next[j] = i 即 next[6] = 3。
9. 然后 j++。
   ```
      i=3
      ↓
   abacabab
          ↑
          j=7
   ```
   比较 p[i] 和 p[j]，它们不相同。下标为 0 到 6 组成的子串的最大公共前后缀为 `"aba"`，令 i 回溯到它自身的最大公共前后缀长度是 1 的位置，即令 i = next[i-1] 即 i = 1，接着往后计算。
   ```
    i=1
    ↓
   abacabab
          ↑
          j=7
   ```
   比较 p[i] 和 p[j]，它们相同。令 i++， next[j] = i 即 next[7] = 1。
10. 然后 j++。因为 j > p，所以结束循环。next=[0, 0, 1, 0, 1, 2, 3, 2]，计算结束。


这里可以查看[这个视频](https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&vd_source=774b9d6a9d7cb9fd98d1187884600dd1&t=431)的动画以便快速理解上面的内容。

---

好，那有了 next 数组之后，匹配字符串的方法就和暴力解法差不多，区别在于当字符匹配失败时，根据 next 数组回溯模式串指针，当回溯至起始位置即 next[j] = 0 时，说明文本串和模式串不存在相同的前缀，i 和 j 就需要同时后移继续比较下一位，直到 j 超过了模式串的长度。

完整的实现代码请点[这里](https://github.com/glitchboyl/CS/blob/main/DataStructure/Algorithm/KMP.c)查看。

---

那么 KMP 算法就完成了。乍看之下挺难的，但实际分析之后理解起来其实还算简单。<br>
我感觉求 next 数组的时候有点像在求线性方程组的基础解系，它们都是用来描述一组对象（字符串和向量）的线性相关性质，通过求解特定的问题（字符串匹配和线性空间的基向量）来计算得出。

本文到这里就结束了，希望以上内容能对你有所帮助。
